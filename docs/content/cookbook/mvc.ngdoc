@ngdoc overview
@name Cookbook: MVC
@description

MVC allows for a clean and testable separation between the behavior (controller) and the view
(HTML template). A Controller is just a JavaScript class which is grafted onto the scope of the
view. This makes it very easy for the controller and the view to share the model.

The model is a set of objects and primitives that are referenced from the Scope ($scope) object.
This makes it very easy to test the controller in isolation since one can simply instantiate the
controller and test without a view, because there is no connection between the controller and the
view.


<doc:example>
  <doc:source>
    <script>
      function TicTacToeCntl($scope, $location) {
          $scope.cellStyle = {
              'height': '20px',
              'width': '20px',
              'border': '1px solid black',
              'text-align': 'center',
              'vertical-align': 'middle',
              'cursor': 'pointer'
          };
      
          $scope.reset = function () {
              $scope.board = [
                  ['', '', ''],
                  ['', '', ''],
                  ['', '', '']
              ];
              $scope.nextMove = 'X';
              $scope.winner = '';
              setUrl();
          };
      
          $scope.dropPiece = function (row, col) {
              if (!$scope.winner && !$scope.board[row][col]) {
                  $scope.board[row][col] = $scope.nextMove;
                  $scope.nextMove = $scope.nextMove == 'X' ? 'O' : 'X';
                  setUrl();
              }
          };
      
          $scope.reset();
          $scope.$watch(function () {
              return $location.search().board;
          }, readUrl);
      
          function setUrl() {
              var rows = [];
              angular.forEach($scope.board, function (row) {
                  rows.push(row.join(','));
              });
              $location.search({
                  board: rows.join(';') + '/' + $scope.nextMove
              });
          }
      
          function grade() {
              var board = $scope.board;
              $scope.winner =
                      rowCheck(0) || rowCheck(1) || rowCheck(2) ||
                      colCheck(0) || colCheck(1) || colCheck(2) ||
                      diagonalCheck(-1) || diagonalCheck(1);
      
              function rowCheck(row) {
                  return same(board[row][0], board[row][1], board[row][2]);
              }
      
              function colCheck(col) {
                  return same(board[0][col], board[1][col], board[2][col]);
              }
      
              function diagonalCheck(diag) {
                  return same(board[0][1 - diag], board[1][1], board[2][1 + diag]);
              }
      
              function same(a, b, c) {
                  return (a == b && b == c) ? a : '';
              };
          }
      
          $scope.tiedGame = function(){
              var board = $scope.board;
              var allMoves = [];
              for(var i in board) {
                  var row = board[i];
                  for(var j in row) {
                      allMoves.push(row[j]);
                  }
              }
              for (i in allMoves) {
                  if (allMoves[i] == '') {
                      return false;
                  }
              }
              return !$scope.winner;
          }
      
          /* Easier solution with Underscore.js
          $scope.tiedGame = function() {
              return !_.contains( _.flatten($scope.board),'') && !$scope.winner;
          }
          */
      
          function readUrl(value) {
              if (value) {
                  value = value.split('/');
                  $scope.nextMove = value[1];
                  angular.forEach(value[0].split(';'), function (row, col) {
                      $scope.board[col] = row.split(',');
                  });
                  grade();
      
              }
          }
      }
    </script>
    <h4>Tic-Tac-Toe</h4>
    <!-- See simpler tiedGame version in script.js for use with Underscoe JS -->
    <!-- <script src="http://underscorejs.org/underscore-min.js"></script> -->

    <div ng-controller="TicTacToeCntl">
        <div ng-show='!tiedGame() && !winner'>Next Player: {{nextMove}}</div>
        <div class="winner" ng-show="winner">Player {{winner}} has won!</div>
        <div class="cats-game" ng-show="tiedGame()">It's a cats game! </div>
        <table class="board">
            <tr ng-repeat="row in board" style="height:15px;">
                <td ng-repeat="cell in row" ng-style="cellStyle"
                    ng-click="dropPiece($parent.$index, $index)">{{cell}}
                </td>
            </tr>
        </table>
        <button ng-click="reset()">reset board</button>
    </div>  
  </doc:source>
  <doc:scenario>
    it('should play a game', function() {
     piece(1, 1);
     expect(binding('nextMove')).toEqual('O');
     piece(3, 1);
     expect(binding('nextMove')).toEqual('X');
     piece(1, 2);
     piece(3, 2);
     piece(1, 3);
     expect(element('.winner').text()).toEqual('Player X has won!');
    });

    function piece(row, col) {
      element('.board tr:nth-child('+row+') td:nth-child('+col+')').click();
    }
  </doc:scenario>
</doc:example>


# Things to notice

* The controller is defined in JavaScript and has no reference to the rendering logic.
* The controller is instantiated by Angular and injected into the view.
* The controller can be instantiated in isolation (without a view) and the code will still execute.
This makes it very testable.
* The HTML view is a projection of the model. In the above example, the model is stored in the
board variable.
* All of the controller's properties (such as board and nextMove) are available to the view.
* Changing the model changes the view.
* The view can call any controller function.
* In this example, the `setUrl()` and `readUrl()` functions copy the game state to/from the URL's
hash so the browser's back button will undo game steps. See deep-linking. This example calls {@link
api/ng.$rootScope.Scope#$watch $watch()} to set up a listener that invokes `readUrl()` when needed.
