@ngdoc overview
@name Developer Guide: Forms
@description

# Overview

Forms allow users to enter data into your application. Forms represent the bidirectional data
bindings in Angular.

Forms consist of all of the following:

  - the individual widgets with which users interact
  - the validation rules for widgets
  - the form, a collection of widgets that contains aggregated validation information


# Form

A form groups a set of widgets together into a single logical data-set. A form is created using
the {@link api/angular.widget.form &lt;form&gt;} element that calls the
{@link api/angular.service.$formFactory $formFactory} service. The form is responsible for managing
the widgets and for tracking validation information.

A form is:

- The collection which contains widgets or other forms.
- Responsible for marshaling data from the model into a widget. This is
  triggered by {@link api/angular.scope.$watch $watch} of the model expression.
- Responsible for marshaling data from the widget into the model. This is
  triggered by the widget emitting the `$viewChange` event.
- Responsible for updating the validation state of the widget, when the widget emits
  `$valid` / `$invalid` event. The validation state is useful for controlling the validation
   errors shown to the user in it consist of:

  - `$valid` / `$invalid`: Complementary set of booleans which show if a widget is valid / invalid.
  - `$error`: an object which has a property for each validation key emited by the widget.
              The value of the key is always true. If widget is valid, then the `$error`
              object has no properties. For example if the widget emits
              `$invalid` event with `REQUIRED` key. The internal state of the `$error` would be
              updated to `$error.REQUIRED == true`.

- Responsible for aggregating widget validation information into the form.

  - `$valid` / `$invalid`: Complementary set of booleans which show if all the child widgets
              (of forms) are valid or if any are invalid.
  - `$error`: an object which has a property for each validation key emited by the
              child widget. The value of the key is an array of widgets which fired the invalid
              event. If all child widgets are valid then, then the `$error` object has no
              properties. For example if a child widget emits
              `$invalid` event with `REQUIRED` key. The internal state of the `$error` would be
              updated to `$error.REQUIRED == [ widgetWhichEmitedInvalid ]`.


# Widgets

In Angular, a widget is the term used for the UI with which the user interacts. Examples of
pre-defined Angular widgets are {@link api/angular.widget.input input} and
{@link api/angular.widget.select select}. Widgets provide the rendering and the user
interaction logic. Widgets should be declared inside a form, if no form is provided an implicit
form {@link api/angular.service.$formFactory $formFactory.root} form is used.

Widgets are implemented as Angular controllers. A widget controller:

-  implements methods:

  - `$render` - Update the DOM from the internal state as represented by `$viewValue`
  - `$parseView` - Translate `$viewValue` to `$modelValue`. (`$modelValue` will be assigned to
     the model scope by the form.)
  - `$parseModel` - Translate `$modelValue` to `$viewValue`. (`$viewValue` will be assigned to
     the DOM inside the `$render` method).

- responds to events:

  - `$validate` - Emitted by the form when the form determines that the widget needs to validate
    itself. There may be more then one listener on the `$validate` event. The widget responds
    by emitting `$valid` / `$invalid` event of its own.

- emits events:

  - `$viewChange` - Emitted when the user interacts with the widget and it is necessary to update
     the model.
  - `$valid` - Emitted when the widget determines that it is valid (usually as a response to
    `$validate` event or inside `$parseView()` or `$parseModel()` method).
  - `$invalid` - Emitted when the widget determines that it is invalid (usually as a response to
    `$validate` event or inside `$parseView()` or `$parseModel()` method).
  - `$destroy` event, when the widget element is removed from the DOM.


# CSS

Angular-defined widgets and forms set `ng-valid` and `ng-invalid` classes on themselves to allow
the web-designer a way to style them. If you write your own widgets, then their `$render()`
methods must set the appropriate CSS classes to allow styling.


# Example

The following example demonstrates:

  - How an error displays when a required field is empty.
  - Error highlighting.
  - How form submission is disabled when the form is invalid.
  - The internal state of the widget and form in the the 'Debug View' area.


<doc:example>
<doc:source>
   <style>
     error { display: inline; color: red; }
     .ng-invalid { border: solid 1px red; }
     .ng-form {display: block;}
   </style>
   <script>
   function UserForm(){
     this.state = /^\w\w$/;
     this.zip = /^\d\d\d\d\d$/;
     this.master = {
       customer: 'John Smith',
       address:{
         line1: '123 Main St.',
         city:'Anytown',
         state:'AA',
         zip:'12345'
       }
     };
     this.cancel();
   }

   UserForm.prototype = {
     cancel: function(){
       this.form = angular.copy(this.master);
     },

     save: function(){
       this.master = this.form;
       this.cancel();
     }
   };
   </script>
   <div ng:controller="UserForm">

     <form name="userForm">

       <label>Name:</label><br/>
       <input type="text" name="customer" ng:model="form.customer" required/>
       <error ng:show="userForm.customer.$error.REQUIRED">Customer name is required!</error>
       <br/><br/>

       <ng:form name="addressForm">
         <label>Address:</label> <br/>
         <input type="text" name="line1" ng:model="form.address.line1" size="33" required/> <br/>
         <input type="text" name="city" ng:model="form.address.city" size="12" required/>,
         <input type="regexp" name="state" ng:regexp="state" ng:model="form.address.state" size="2" required/>
         <input type="regexp" name="zip" ng:regexp="zip" ng:model="form.address.zip" size="5" required/><br/><br/>

         <error ng:show="addressForm.$invalid">
           Incomplete address:
           <error ng:show="addressForm.state.$error.REQUIRED">Missing state!</error>
           <error ng:show="addressForm.state.$error.REGEXP">Invalid state!</error>
           <error ng:show="addressForm.zip.$error.REQUIRED">Missing zip!</error>
           <error ng:show="addressForm.zip.$error.REQEXP">Invalid zip!</error>
         </error>

       </ng:form>

       <button ng:click="cancel()" ng:disabled="{{master.$equals(form)}}">Cancel</button>
       <button ng:click="save()" ng:disabled="{{userForm.$invalid || master.$equals(form)}}">Save</button>
     </form>

     <hr/>
     Debug View:
     <pre>form={{form}}</pre>
     <pre>master={{master}}</pre>
     <pre>userForm={{userForm}}</pre>
     <pre>addressForm={{addressForm}}</pre>
   </div>
</doc:source>
<doc:scenario>
  it('should enable save button', function(){
    expect(element(':button:contains(Save)').attr('disabled')).toBeTruthy();
    input('form.customer').enter('');
    expect(element(':button:contains(Save)').attr('disabled')).toBeTruthy();
    input('form.customer').enter('change');
    expect(element(':button:contains(Save)').attr('disabled')).toBeFalsy();
    element(':button:contains(Save)').click();
    expect(element(':button:contains(Save)').attr('disabled')).toBeTruthy();
  });
  it('should enable cancel button', function(){
    expect(element(':button:contains(Cancel)').attr('disabled')).toBeTruthy();
    input('form.customer').enter('change');
    expect(element(':button:contains(Cancel)').attr('disabled')).toBeFalsy();
    element(':button:contains(Cancel)').click();
    expect(element(':button:contains(Cancel)').attr('disabled')).toBeTruthy();
    expect(element(':input[ng\\:model="form.customer"]').val()).toEqual('John Smith');
  });
</doc:scenario>
</doc:example>

# Life-cycle Overview

- The `<form>` element triggers creation of a new form scope using the
  {@link api/angular.service.$formFactory $formfactory}. The new form scope is added to the
  `<form>` element using the jQuery `.data()` method for later retrieval under the key `$form`.
  The form also sets up these listeners

  - `$destroy`: This event is emitted by the widget when it is removed from the view. It gives the
     form a chance to clean up any validation references to the destroyed widget.
  - `$valid` / `$invalid`: This event is fired by the widget on validation state change.

- `<input>` element triggers the creation of the widget using the
  {@link api/angular.service.$formFactory $formfactory.$createWidget()} method. The `$createWidget()`
  crates new widget instance by calling the current scope {@link api/angular.scope.$new .$new()} and
  registers these listeners:

  - `$watch` on the model scope.
  - `$viewChange` event on the widget scope.
  - `$validate` event on the widget scope.
  - Element `change` event when the user enters data.


- When the user interacts with the widget:

  1. The DOM element fires the `change` event which the widget intercepts. Widget then emits
     a `$viewChange` event which includes the new user-entered value. (Remember that the DOM events
     are outside of the Angular environment so the widget must emit its event within the
     {@link api/angular.scope.$apply $apply} method).
  2. The form's `$viewChange` listener copies the user-entered value to the widget's `$viewValue`
     property. Since the `$viewValue` is the raw value as entered by user, it may need to be
     translated to a different format/type (for example, translating a string to a number).
     If you need your widget to translate between the internal `$viewValue` and the external
     `$modelValue` state, you must declare a `$parseView()` method. The `$parseView()` method
     will copy `$viewValue` to `$modelValue` and perform any necessary translations.
  3. The form then emits a `$validate` event, giving the widget's validators chance to validate the
     input. There can be any number of validators registered. Each validator may in turn
     emit a `$valid` / `$invalid` event with the validator's validation key. For example `REQUIRED`.
  4. Form listens to `$valid`/`$invalid` events and updates both the form as well as the widget
     scope with the validation state. The validation updates the `$valid` and `$invalid`, property
     as well as `$error` object. The widget's `$error` object is updated with the validation key
     such that `$error.REQUIRED == true` when the validation emits `$invalid` with `REQUIRED`
     validation key. Similarly the form's `$error` object gets updated, but instead of boolean
     `true` it contains an array of invalid widgets (widgets which fired `$invalid` event with
     `REQUIRED` validation key).

- When the model is updated:

  1. The `$watch` listener on the model assigns the model value to `$modelValue` on the widget.
  2. The form then calls `$parseModel` method on widget if present. The method converts the
     value to renderable format and assigns it to `$viewValue` (for example converting number to a
     string)
  3. The form then emits a `$validate` which behaves as described above.
  4. The form then calls `$render` method on the widget to update the DOM structure from the
     `$viewValue`



# Form's Responsibility

The form is responsible for creating, managing the lifecycle and updating the the validation
state of widgets and itself.

A widget is just an Angular controller class. It is instantiated using the
{@link api/angular.service.$formFactory $formFactroy.$createWidget()} method. The instantiation
typically takes place inside the compiler's {@link api/angular.widget angular.widget} directive.
The new widget is a child scope of the form scope.

The creation of the widget involves setting up a `$watch` on the model scope. And notifying the
widget using the `$parseModel()` of model changes, and then updating the UI using the `$render()`
method. The form listens to the widget`s `$viewChange` event to `$parseView` and the update the
model with  the new value. If at any point the widget fires `$valid` or `$invalid` event, the
form updates the state (`$valid`, `$invalid` and `$error` properties) of the widget and the form
itself.


# Widget's Responsibility

The author of the widget is responsible for implementing following behavior:

* **Listen on DOM events**: Widgets will allow users to interact with the DOM, therefore the
  widget will need to register appropriate events for the widget interaction.
  Because these events are angular life-cycle, they need to be executed inside the
  {@link api/angualar.scope.$apply()} method.
* **Listen on DOM destruction**: A widget may be removed from the DOM while it is invalid. To
  properly update the validity of the containing form, the widget must call $destroy on its scope,
  which will fire the `$destroy` event and notify form of removal. This is achieved by
  registering a `$destroy` event on the element, using the `.bind()` method, that calls
  {@link api/angular.scope.$destroy() $destroy()} method.
* **Listen on `$validate` event and emit `$valid` / `$invalid` events**: Widget may chose to
  listen on `$validate` and respond with by emitting `$valid` / `$invalid`.
* **`$parseModel()`**: Widget may implement a `$parseModel()` method which is invoked when the
  `$modelValue` needs to be converted to `$viewValue`.
* **`$parseView()`**: Widget may implement a `$parseView()` method which is invoked when the
  `$viewValue` need to be converted to `$modelValue`.
* **`$render`**: A `$render` method is invoked whenever the DOM needs to be updated from the
  `$viewValue`.

# Writing Your Own Widget

This example shows how to implement a custom widget in Angular.

    <doc:example>
      <doc:source jsfiddle="false">
        <script>
          function EditorCntl(){
            this.html = '<b>Hello</b> <i>World</i>!';
          }

          ContentEditableWidget.$inject = [];
          function ContentEditableWidget(element) {
            var self = this;
            var htmlFilter = angular.filter('html');

            this.$parseModel = function(){
              // need to protect for script injection
              try {
                this.$viewValue = htmlFilter(this.$modelValue || '').get();
                if (this.$error.HTML) {
                  // we were invalid, but now we are OK.
                  this.$emit('$valid', 'HTML');
                }
              } catch (e) {
                // if HTML not parsable invalidate form.
                this.$emit('$invalid', 'HTML');
              }
            }

            this.$render = function(){
              element.html(this.$viewValue);
            }

            element.bind('keyup', function(){
              self.$apply(function(){
                self.$emit('$viewChange', element.html());
              });
            });
          }

          angular.directive('ng:contenteditable', function(){
            function linkFn($formFactory, element) {
              var exp = element.attr('ng:contenteditable'),
                  form = $formFactory.forElement(element),
                  widget;
              element.attr('contentEditable', true);
              widget = form.$createWidget(this, exp, null, null, ContentEditableWidget, element);
              // if the element is destroyed, then we need to notify the form.
              element.bind('$destroy', function(){
                widget.$destroy();
              });
            }
            linkFn.$inject = ['$formFactory'];
            return linkFn;
          });
        </script>
        <form name='editorForm' ng:controller="EditorCntl">
          <div ng:contenteditable="html"></div>
          <hr/>
          HTML: <br/>
          <textarea ng:model="html" cols=80></textarea>
          <hr/>
          <pre>editorForm = {{editorForm}}</pre>
        </form>
      </doc:source>
      <doc:scenario>
        it('should enter invalid HTML', function(){
          expect(element('form[name=editorForm]').prop('className')).toMatch(/ng-valid/);
          input('html').enter('<');
          expect(element('form[name=editorForm]').prop('className')).toMatch(/ng-invalid/);
        });
      </doc:scenario>
    </doc:example>






