@ngdoc overview
@name  Services
@sortOrder 230
@description

# 服务

Angular 的服务是通过 {@link di 依赖注入 (DI)}联接起来的可替代对象。 你可以通过服务来跨应用组织和共享代码。

Angular 服务的特点:

* 惰性初始模式 – Angular 只有在应用组件依赖这个服务的的时候才对它做实例化。
* 单例模式 – 服务工厂只产生一个实例，每个依赖这个服务的组件只会得到它的一个引用。

Angular 提供若干有用的服务 (例如 {@link ng.$http `$http`}), 但是对于大多数应用，你可能想要
{@link services#creating-services 创建你自己的服务}。

<div class="alert alert-info">
**注意:** 和Angular其他的核心标示符一样, 内建的服务总是以 `$`开头
(e.g. `$http`).
</div>


## 使用一个服务

想要使用一个Angular服务，你需要把它加入基于这个服务的组件(控制器，服务，过滤器或者指令)的依赖里。
Angular的 {@link di 依赖注入}子系统负责剩下的工作。

<example module="myServiceModule">
  <file name="index.html">
    <div id="simple" ng-controller="MyController">
      <p>Let's try this simple notify service, injected into the controller...</p>
      <input ng-init="message='test'" ng-model="message" >
      <button ng-click="callNotify(message);">NOTIFY</button>
      <p>(you have to click 3 times to see an alert)</p>
    </div>
  </file>

  <file name="script.js">
    angular.
     module('myServiceModule', []).
      controller('MyController', ['$scope','notify', function ($scope, notify) {
        $scope.callNotify = function(msg) {
          notify(msg);
        };
      }]).
     factory('notify', ['$window', function(win) {
        var msgs = [];
        return function(msg) {
          msgs.push(msg);
          if (msgs.length == 3) {
            win.alert(msgs.join("\n"));
            msgs = [];
          }
        };
      }]);
  </file>

  <file name="protractor.js" type="protractor">
    it('should test service', function() {
      expect(element(by.id('simple')).element(by.model('message')).getAttribute('value'))
          .toEqual('test');
    });
  </file>
</example>


## 创建服务

在一个Angular模块里，应用开发人员可以通过注册服务名和**服务工厂函数**自由的定义他们自己的服务。

**服务工厂函数** 生成单个对象或函数，生成的对象或者函数在整个应用中代表这个服务。服务返回的对象
或函数会被注入的任何声明依赖这个服务的组件（控制器，服务，过滤器或指令）中。

### 注册服务

服务通过 {@link angular.Module 模块 API}注册到模块。
通常你可以用 {@link angular.module Module#factory} API 来注册服务:

```js
var myModule = angular.module('myModule', []);
myModule.factory('serviceId', function() {
  var shinyNewServiceInstance;
  // factory function body that constructs shinyNewServiceInstance
  return shinyNewServiceInstance;
});
```

注意你没有注册 **服务实例**, 而是注册了一个在调用时产生这个实例的 **工厂函数** 。

### 依赖

服务可以有依赖。 和在控制器中声明依赖一样, 你可以把依赖放在服务的工厂函数的签名里来声明。

更多关于依赖的内容，请参考 {@link guide/di 依赖注入} 文档。

下面的示例模块包含两个服务，每个服务都有几个依赖:

```js
var batchModule = angular.module('batchModule', []);

/**
 * The `batchLog` service allows for messages to be queued in memory and flushed
 * to the console.log every 50 seconds.
 *
 * @param {*} message Message to be logged.
 */
batchModule.factory('batchLog', ['$interval', '$log', function($interval, $log) {
  var messageQueue = [];

  function log() {
    if (messageQueue.length) {
      $log.log('batchLog messages: ', messageQueue);
      messageQueue = [];
    }
  }

  // start periodic checking
  $interval(log, 50000);

  return function(message) {
    messageQueue.push(message);
  }
}]);

/**
 * `routeTemplateMonitor` monitors each `$route` change and logs the current
 * template via the `batchLog` service.
 */
batchModule.factory('routeTemplateMonitor', ['$route', 'batchLog', '$rootScope',
  function($route, batchLog, $rootScope) {
    $rootScope.$on('$routeChangeSuccess', function() {
      batchLog($route.current ? $route.current.template : null);
    });
  }]);

```

在这个例子里，注意一下几点:

* `batchLog` 服务依赖内建的 {@link ng.$interval `$interval`} 和 {@link ng.$log `$log`} 服务。
* `routeTemplateMonitor` 服务依赖内建的 {@link ngRoute.$route `$route`} 服务和我们定制的 `batchLog` 服务.
* 所有的服务都使用数组符号声明它们的依赖。
* 标示符在数组中的顺序和参数名在工厂函数中的顺序是一致的。

### 用 `$provide` 注册服务

你也可以用{@link auto.$provide `$provide`}服务代替模块的 `config`函数来注册服务:

```js
angular.module('myModule', []).config(['$provide', function($provide) {
  $provide.factory('serviceId', function() {
    var shinyNewServiceInstance;
    // factory function body that constructs shinyNewServiceInstance
    return shinyNewServiceInstance;
  });
}]);
```

这项技术经常用来在单元测试中模拟服务的依赖。


## 单元测试

 下面是上面的{@link services#creating-services创建 Angular 服务} 示例中的`notify`服务
 的一个单元测试。 示例的单元测试中使用一个Jasmine spy (mock)代替真正的浏览器警告。

```js
var mock, notify;

beforeEach(function() {
  mock = {alert: jasmine.createSpy()};

  module(function($provide) {
    $provide.value('$window', mock);
  });

  inject(function($injector) {
    notify = $injector.get('notify');
  });
});

it('should not alert first two notifications', function() {
  notify('one');
  notify('two');

  expect(mock.alert).not.toHaveBeenCalled();
});

it('should alert all after third notification', function() {
  notify('one');
  notify('two');
  notify('three');

  expect(mock.alert).toHaveBeenCalledWith("one\ntwo\nthree");
});

it('should clear messages after alert', function() {
  notify('one');
  notify('two');
  notify('third');
  notify('more');
  notify('two');
  notify('third');

  expect(mock.alert.callCount).toEqual(2);
  expect(mock.alert.mostRecentCall.args).toEqual(["more\ntwo\nthird"]);
});
```


## 相关主题

* {@link guide/di AngularJS中的依赖注入}

## 相关 API

* {@link ./api/ng/service Angular 服务 API}
* {@link angular.injector 注入 API}
