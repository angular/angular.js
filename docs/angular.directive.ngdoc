@workInProgress
@ngdoc overview
@name angular.directive
@namespace Namespace for all directives.

@description
An angular directive is an HTML attribute.  You can use directives to modify a DOM element's
properties.  The element you modify can be an existing HTML element type, or a DOM element type
that you create as an {@link angular.widget}. You can use any number of directives per element.

For example, you could add the {@link angular.directive.ng:bind ng:bind} directive as an attribute
of an HTML span element, as in:

         <span ng:bind="1+2"></span>  

How does this work? The angular {@link guide.compiler compiler} passes the attribute value `1+2`
to the `ng:bind` extension, which in turn tells the {@link angular.scope} to watch that expression
in the data model and report changes. On any change to the expression in the model, the scope sets
the span text to the expression value. 

Here's how to define {@link angular.directive.ng:bind ng:bind}:
<pre>
angular.directive('ng:bind', function(expression, compiledElement) {
  var compiler = this;
  return function(linkElement) {
    var currentScope = this;
    currentScope.$watch(expression, function(value) {
      linkElement.text(value);
    });
  };
});
</pre>

# Directives vs. Attribute Widgets
Directives and attribute widgets look the same in a template (`ng:init` is a directive,
`ng:repeat` is an attribute widget), but they behave slightly differently.

[Attribute widgets](#!angular.widget) and directives can both compile a DOM element
attribute, so why have two different ways to do the same thing? The answer is that the order in
which attribute directives get processed matters, but we have no control over the order in which
attributes are read. To solve this, we use an attribute widget.  Widgets always run before
directives in a particular element. So we apply an attribute widget before any directives when we
need to control the order in which attributes are processed.  Widgets may manipulate the DOM,
whereas directives are not expected to do so, and so directives run after widgets.

For example, consider this piece of HTML, which uses `ng:repeat`, `ng:init`, and `ng:bind`:
<pre>
<ul ng:init="people=['mike', 'mary']">
  <li ng:repeat="person in people" ng:init="a=a+1" ng:bind="person"></li>
</ul>
</pre>

Notice that the order of execution matters here. We need to execute
{@link angular.directive.ng:repeat ng:repeat} before we run the
{@link angular.directive.ng:init ng:init} and {@link angular.directive.ng:bind ng:bind} on the
`<li/>;`. This is because we want to run the `ng:init="a=a+1` and `ng:bind="person"` once for each
`person in people`. We could not have used a directive to implement the repeater in this template,
because attributes are read in an unspecified order and there is no way of guaranteeing that the
repeater attribute would execute first. Using the `ng:repeat` attribute widget ensures that we can
transform the DOM element into the template we intended.
